<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Collection - NFT Marketplace</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/limonte-sweetalert2/11.10.1/sweetalert2.min.css">

    <style>
        .gradient-bg {
            background: linear-gradient(90deg, #4F46E5, #7C3AED);
        }
        .card-hover:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        .card {
            transition: all 0.3s ease;
        }
        .tab-active {
            border-bottom: 2px solid #4F46E5;
            color: #4F46E5;
        }
        .modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

.modal-content {
  background-color: white;
  padding: 30px;
  border-radius: 10px;
  text-align: center;
  max-width: 400px;
  width: 90%;
}

.modal-ok-btn {
  margin-top: 20px;
  display: inline-block;
  padding: 10px 20px;
  background-color: #6366f1;
  color: white;
  border-radius: 5px;
  text-decoration: none;
}
.modal-buttons {
  margin-top: 20px;
  display: flex;
  justify-content: space-around;
}

.modal-cancel-btn {
  background-color: #e5e7eb;
  color: #111827;
  padding: 10px 20px;
  border-radius: 5px;
}

.modal-ok-btn {
  background-color: #ef4444; /* Red */
  color: white;
  padding: 10px 20px;
  border-radius: 5px;
}


    </style>
</head>
<body class="bg-gray-100 font-sans">
    <!-- Navigation -->
    <nav class="gradient-bg text-white shadow-lg">
        <div class="container mx-auto px-4">
            <div class="flex justify-between items-center py-1">
                <div class="flex items-center space-x-2">
                    <i class="fas fa-palette text-2xl"></i>
                    <a href="Home.html" class="text-2xl font-bold">NFT Marketplace</a>
                </div>
                <div class="hidden md:flex space-x-8">
                    <a href="Home.html" class="hover:text-purple-200 transition-colors duration-300 flex items-center">
                        <i class="fas fa-compass mr-2"></i>Explore
                    </a>
                    <a href="create-nft.html" class="hover:text-purple-200 transition-colors duration-300 flex items-center">
                        <i class="fas fa-paint-brush mr-2"></i>Create
                    </a>
                    <a href="my-collection.html" class="hover:text-purple-200 transition-colors duration-300 flex items-center">
                        <i class="fas fa-layer-group mr-2"></i>My Collection
                    </a>
                     <a href="auction-market.html" class="hover:text-purple-200 transition-colors duration-300 flex items-center">
                      <i class="fas fa-gavel mr-2"></i>Auction
                  </a>
                </div>
                <div class="flex items-center space-x-4">
                    <button id="connectWalletBtn" class="bg-white text-indigo-600 font-medium py-2 px-6 rounded-full hover:bg-purple-100 transition duration-300 flex items-center space-x-2 pulse shadow-lg">
                        <i class="fas fa-wallet mr-2"></i><span id="walletBtnText">Connect Wallet</span>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <!-- Profile Header -->
    <section class="relative">
        <div class="h-60 bg-gradient-to-r from-indigo-600 to-purple-600"></div>
        <div class="container mx-auto px-4">
            <div class="relative -mt-40 mb-6 flex flex-col md:flex-row items-center md:items-end space-y-4 md:space-y-0">
                <div class="z-10">
                    <img id="profileImage" src="https://randomuser.me/api/portraits/men/32.jpg" alt="Profile" class="w-32 h-32 rounded-full border-4 border-white">
                </div>
                <div class="md:ml-6 text-center md:text-left">
                    <h1 id="profileName" class="text-2xl font-bold">Crypto Collector</h1>
                    <div class="flex items-center justify-center md:justify-start space-x-2 mt-1">
                        <p id="profileUsername" class="text-dark-600">@collector</p>
                        <span class="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full">Verified</span>
                    </div>
                    <p id="profileBio" class="text-brown-600 mt-1 max-w-lg">Passionate NFT collector and digital art enthusiast. Building a curated collection of the finest digital art pieces.</p>
                </div> 
                <div class="md:ml-auto flex flex-col md:flex-row items-center space-y-2 md:space-y-0 md:space-x-3">
                    <button id="editProfileBtn" class="gradient-bg text-white font-medium py-2 px-6 rounded-full hover:opacity-90 transition duration-300">
                        <i class="fas fa-edit mr-2"></i>Edit Profile
                    </button>
                   
                </div>
            </div>
           
        </div>
    </section>

    <!-- Collection Tabs -->
    <section class="py-8">
        <div class="container mx-auto px-4">
            <div class="flex overflow-x-auto border-b border-gray-200 mb-8 pb-1">
                <button class="tab-active text-gray-500 px-4 py-2 font-medium mr-6 focus:outline-none" data-tab="created">My NFTs</button>
                <button class="text-gray-500 px-4 py-2 font-medium focus:outline-none" data-tab="bids">Active Bids</button>
            </div>

            </div> 

            <!-- Other tabs (hidden by default) -->
            <div id="created-tab" class="tab-content">
                <div id="nftGrid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
                    <!-- Created NFTs will go here -->
                     
                </div>
                <div id="emptyState" class="text-center py-12">
                    <i class="fas fa-image text-5xl text-gray-300 mb-4"></i>
                    <h3 class="text-xl font-semibold mb-2">No items found</h3>
                    <p class="text-gray-500 mb-4">Create your first NFT</p>
                    <a href="create-nft.html" class="gradient-bg text-white font-medium py-2 px-6 rounded-full hover:opacity-90 transition duration-300">
                        Create NFT
                    </a>
                </div>
            </div>
            
         
            <div id="bids-tab" class="tab-content hidden">
                <div id="activeBidsList" class="grid grid-cols-1 gap-4">
                    <!-- Active bids will be loaded here -->
                </div>
                <div id="emptyBidsState" class="text-center py-12">
                    <i class="fas fa-hand-paper text-4xl text-gray-400 mb-3"></i>
                    <h3 class="text-xl font-semibold mb-2">No active bids</h3>
                    <p class="text-gray-500 mb-4">You haven't placed any bids yet</p>
                    <a href="Home.html" class="gradient-bg text-white font-medium py-2 px-6 rounded-full hover:opacity-90 transition duration-300">
                        Browse NFTs
                    </a>
                </div>
            </div>
        </div>

    </section>

    <!-- Profile Edit Modal -->
    <div id="editProfileModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl p-6 w-full max-w-md">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-xl font-bold">Edit Profile</h3>
                <button id="closeModalBtn" class="text-gray-500 hover:text-gray-700">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="space-y-4">
                <div class="flex justify-center mb-6">
                    <div class="relative">
                        <img id="previewProfileImg" src="https://randomuser.me/api/portraits/men/32.jpg" alt="Profile" class="w-24 h-24 rounded-full border-2 border-gray-200">
                        <label for="profileImageInput" class="absolute bottom-0 right-0 bg-indigo-600 text-white rounded-full w-8 h-8 flex items-center justify-center cursor-pointer">
                            <i class="fas fa-camera"></i>
                        </label>
                        <input type="file" id="profileImageInput" accept="image/*" class="hidden">
                    </div>
                </div>
                <div>
                    <label class="block text-gray-700 mb-1">Display Name</label>
                    <input id="nameInput" type="text" class="w-full border border-gray-300 rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Your Name">
                </div>
                <div>
                    <label class="block text-gray-700 mb-1">Username</label>
                    <input id="usernameInput" type="text" class="w-full border border-gray-300 rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="@username">
                </div>
                <div>
                    <label class="block text-gray-700 mb-1">Bio</label>
                    <textarea id="bioInput" class="w-full border border-gray-300 rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500" rows="3" placeholder="Tell about yourself"></textarea>
                </div>
                <button id="saveProfileBtn" class="w-full gradient-bg text-white font-medium py-2 px-6 rounded-md hover:opacity-90 transition duration-300 mt-4">
                    Save Changes
                </button>
            </div>
        </div>
    </div>
    <div id="list" class="modal" style="display: none;">
  <div class="modal-content">
    <h2>NFT Listed successfully!</h2>
    <p id="modalMessage"></p>
    <a href="my-collection.html" id="modalOkBtn" class="modal-ok-btn">OK</a>
  </div>
</div>


  <div id="cancel" class="modal" style="display: none;">
  <div class="modal-content">
    <h2>NFT successfully canceled!</h2>
    <p id="modalMessage"></p>
    <a href="my-collection.html" id="modalOkBtn" class="modal-ok-btn">OK</a>
  </div>
</div>

<div id="cancelModal" class="modal" style="display: none;">
  <div class="modal-content">
    <h2>Cancel Listing</h2>
    <p>This action cannot be undone. Are you sure you want to cancel this listing?</p>
    <div class="modal-buttons">
      <button id="confirmCancelBtn" class="modal-ok-btn">Yes, Cancel</button>
      <button id="dismissCancelBtn" class="modal-cancel-btn">No, Go Back</button>
    </div>
  </div>
</div>


    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/limonte-sweetalert2/11.10.1/sweetalert2.all.min.js"></script>

    <script>

const CONTRACT_ADDRESS = "0x896eeE55B5a8783d45D11c4Ad64a5941fAf41934";
const CONTRACT_ABI = [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "ERC721IncorrectOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "ERC721InsufficientApproval",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "approver",
          "type": "address"
        }
      ],
      "name": "ERC721InvalidApprover",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "ERC721InvalidOperator",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "ERC721InvalidOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        }
      ],
      "name": "ERC721InvalidReceiver",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "ERC721InvalidSender",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "ERC721NonexistentToken",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "OwnableInvalidOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "OwnableUnauthorizedAccount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ReentrancyGuardReentrantCall",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "approved",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "winner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "AuctionEnded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "bidder",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "BidPlaced",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "bidder",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "BidWithdrawn",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "ListingCancelled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "seller",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "enum NFTCollection.SaleType",
          "name": "saleType",
          "type": "uint8"
        }
      ],
      "name": "NFTListed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "seller",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "buyer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "name": "NFTSold",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "RoyaltyPaid",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "activeListings",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "asks",
      "outputs": [
        {
          "internalType": "address",
          "name": "seller",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "active",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "auctionBids",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "bidders",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "bids",
      "outputs": [
        {
          "internalType": "address",
          "name": "buyer",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "active",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "buyNFT",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "cancelListing",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "name": "createAsk",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "createBid",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "endAuction",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getActiveListings",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "getApproved",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "getBidHistory",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "getListing",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "seller",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "price",
              "type": "uint256"
            },
            {
              "internalType": "enum NFTCollection.SaleType",
              "name": "saleType",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "auctionEndTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "highestBid",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "highestBidder",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "active",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "listingTime",
              "type": "uint256"
            }
          ],
          "internalType": "struct NFTCollection.Listing",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "salePrice",
          "type": "uint256"
        }
      ],
      "name": "getRoyaltyInfo",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "getUserBid",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "isListed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "startingPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "durationInSeconds",
          "type": "uint256"
        }
      ],
      "name": "listNFTAuction",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "name": "listNFTFixedPrice",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "listings",
      "outputs": [
        {
          "internalType": "address",
          "name": "seller",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        },
        {
          "internalType": "enum NFTCollection.SaleType",
          "name": "saleType",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "auctionEndTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "highestBid",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "highestBidder",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "active",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "listingTime",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "uri",
          "type": "string"
        }
      ],
      "name": "mint",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "ownerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "placeBid",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "salePrice",
          "type": "uint256"
        }
      ],
      "name": "royaltyInfo",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "uint16",
          "name": "fraction",
          "type": "uint16"
        }
      ],
      "name": "setDefaultRoyalty",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "uint16",
          "name": "fraction",
          "type": "uint16"
        }
      ],
      "name": "setTokenRoyalty",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "tokenURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "withdrawBid",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
];

        if (!localStorage.getItem('clearedDemoNFTs')) {
    localStorage.removeItem('nftItems');
    localStorage.removeItem('createdNFTs');
    localStorage.setItem('clearedDemoNFTs', 'true');
}


        // Modified wallet connection functionality
        document.addEventListener('DOMContentLoaded', function() {
            const connectWalletBtn = document.getElementById('connectWalletBtn');
            const myCollectionLink = document.querySelector('a[href="my-collection.html"]');
            
            // Hide My Collection link by default
            if (myCollectionLink) {
                myCollectionLink.style.display = 'none';
            }
            
            // Check if user is already connected (from localStorage)
            const connectedAccount = localStorage.getItem('connectedWalletAccount');
            if (connectedAccount) {
                // Update button with account info
                connectWalletBtn.textContent = connectedAccount.slice(0, 6) + '...' + connectedAccount.slice(-4);
                connectWalletBtn.classList.add('bg-green-100');
                connectWalletBtn.classList.add('text-green-600');
                
                // Show My Collection link
                if (myCollectionLink) {
                    myCollectionLink.style.display = 'block';
                }
            }
            
            // Wallet connection handler
            connectWalletBtn.addEventListener('click', function() {
                if (typeof window.ethereum !== 'undefined') {
                    // Request account access
                    ethereum.request({ method: 'eth_requestAccounts' })
                    .then(accounts => {
                        // Connected successfully
                        const account = accounts[0];
                        connectWalletBtn.textContent = account.slice(0, 6) + '...' + account.slice(-4);
                        connectWalletBtn.classList.add('bg-green-100');
                        connectWalletBtn.classList.add('text-green-600');
                        
                        // Store connection in localStorage
                        localStorage.setItem('connectedWalletAccount', account);
                        
                        // Show My Collection link
                        if (myCollectionLink) {
                            myCollectionLink.style.display = 'block';
                        }
                    })
                    .catch(error => {
                        console.error("User denied account access");
                        alert("Connection rejected. Please connect your wallet to use the marketplace.");
                    });
                } else {
                    alert("Ethereum wallet not detected! Please install MetaMask or another wallet provider.");
                }
            });
            loadProfileData();
            loadActiveBids();

        });
            
           
        
        
        // Tab switching functionality
        const tabButtons = document.querySelectorAll('[data-tab]');
        tabButtons.forEach(button => {
            button.addEventListener('click', function() {
                // Remove active class from all tabs
                tabButtons.forEach(btn => {
                    btn.classList.remove('tab-active');
                    btn.classList.add('text-gray-500');
                });
                
                // Add active class to clicked tab
                this.classList.add('tab-active');
                this.classList.remove('text-gray-500');
                if (this.dataset.tab === 'bids') {
                loadActiveBids();
            }
                // Hide all tab content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.add('hidden');
                });
                
                // Show selected tab content
                document.getElementById(`${this.dataset.tab}-tab`).classList.remove('hidden');
            });
        });
        
        // Profile editing functionality
        const editProfileBtn = document.getElementById('editProfileBtn');
        const editProfileModal = document.getElementById('editProfileModal');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const saveProfileBtn = document.getElementById('saveProfileBtn');
        const profileImageInput = document.getElementById('profileImageInput');
        const previewProfileImg = document.getElementById('previewProfileImg');
        
        // Open modal
        editProfileBtn.addEventListener('click', function() {
            editProfileModal.classList.remove('hidden');
            
            // Fill form with current values
            document.getElementById('nameInput').value = document.getElementById('profileName').textContent;
            document.getElementById('usernameInput').value = document.getElementById('profileUsername').textContent.replace('@', '');
            document.getElementById('bioInput').value = document.getElementById('profileBio').textContent;
            document.getElementById('previewProfileImg').src = document.getElementById('profileImage').src;
        });
        
        // Close modal
        closeModalBtn.addEventListener('click', function() {
            editProfileModal.classList.add('hidden');
        });
        
        // Preview profile image
        profileImageInput.addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    previewProfileImg.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
        
        // Save profile changes
        saveProfileBtn.addEventListener('click', function() {
            const name = document.getElementById('nameInput').value;
            const username = document.getElementById('usernameInput').value;
            const bio = document.getElementById('bioInput').value;
            const profileImg = document.getElementById('previewProfileImg').src;
            
            // Update the profile in the UI
            document.getElementById('profileName').textContent = name;
            document.getElementById('profileUsername').textContent = '@' + username;
            document.getElementById('profileBio').textContent = bio;
            document.getElementById('profileImage').src = profileImg;
            
            // Save profile data to localStorage
            const profileData = {
                name: name,
                username: username,
                bio: bio,
                profileImg: profileImg
            };
            localStorage.setItem('profileData', JSON.stringify(profileData));
            
            // Close modal
            editProfileModal.classList.add('hidden');
        });
        
        // Load profile data from localStorage
        function loadProfileData() {
            const profileData = JSON.parse(localStorage.getItem('profileData'));
            if (profileData) {
                document.getElementById('profileName').textContent = profileData.name;
                document.getElementById('profileUsername').textContent = '@' + profileData.username;
                document.getElementById('profileBio').textContent = profileData.bio;
                document.getElementById('profileImage').src = profileData.profileImg;
            }
        }

function showSuccessModal() {
  const modal = document.getElementById("list");
  modal.style.display = "block";

  document.getElementById("modalOkBtn").onclick = () => {
    modal.style.display = "none";
  };

  // Optional: close if clicking outside
  window.onclick = function(event) {
    if (event.target === modal) {
      modal.style.display = "none";
    }
  };
}
function showSuccessModal() {
  const modal = document.getElementById("cancel");
  modal.style.display = "block";

  document.getElementById("modalOkBtn").onclick = () => {
    modal.style.display = "none";
  };

  // Optional: close if clicking outside
  window.onclick = function(event) {
    if (event.target === modal) {
      modal.style.display = "none";
    }
  };
}


// Function to load NFTs from the contract for the Created tab
async function loadCreatedNFTsFromContract() {
    const createdTab = document.querySelector('#created-tab');
    const nftGrid = createdTab.querySelector('#nftGrid');
    const emptyState = createdTab.querySelector('#emptyState');
    
    // Check if MetaMask is installed
    if (!window.ethereum) {
        nftGrid.innerHTML = '<div class="col-span-full text-center py-12"><i class="fas fa-exclamation-circle text-3xl text-yellow-500"></i><p class="mt-2 text-gray-600">MetaMask not installed. Please install MetaMask to view your created NFTs.</p></div>';
        return;
    }

    // Check if wallet is connected
    const connectedAccount = localStorage.getItem('connectedWalletAccount');
    if (!connectedAccount) {
        nftGrid.innerHTML = '<div class="col-span-full text-center py-12"><i class="fas fa-wallet text-3xl text-gray-400"></i><p class="mt-2 text-gray-600">Please connect your wallet to view your NFTs</p><button id="connectWalletInTabBtn" class="mt-4 gradient-bg text-white font-medium py-2 px-6 rounded-full hover:opacity-90 transition duration-300">Connect Wallet</button></div>';
        
        // Add event listener to the button
        setTimeout(() => {
            const connectBtn = document.getElementById('connectWalletInTabBtn');
            if (connectBtn) {
                connectBtn.addEventListener('click', async function() {
                    try {
                        // Request account access
                        const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
                        const account = accounts[0];
                        
                        // Store connection in localStorage
                        localStorage.setItem('connectedWalletAccount', account);
                        
                        // Update button with account info
                        const connectWalletBtn = document.getElementById('connectWalletBtn');
                        if (connectWalletBtn) {
                            connectWalletBtn.textContent = account.slice(0, 6) + '...' + account.slice(-4);
                            connectWalletBtn.classList.add('bg-green-100');
                            connectWalletBtn.classList.add('text-green-600');
                        }
                        
                        // Load NFTs after connection
                        loadCreatedNFTsFromContract();
                    } catch (error) {
                        console.error('Error connecting wallet:', error);
                        alert('Failed to connect wallet. Please try again.');
                    }
                });
            }
        }, 100);
        return;
    }

    // Show loading state
    nftGrid.innerHTML = '<div class="col-span-full text-center py-12"><i class="fas fa-spinner fa-spin text-3xl text-indigo-600"></i><p class="mt-2 text-gray-600">Loading your NFTs from the blockchain...</p></div>';

    try {
        // Connect to the contract
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, provider);
        
        // Get total supply of tokens
        const total = await contract.totalSupply();
        
        // Array to store the user's NFTs
        const ownedNFTs = [];

        // Loop through all tokens and check ownership
        for (let i = 1; i <= total; i++) {
            try {
                // Get the owner of the token
                const owner = await contract.ownerOf(i);
                
                // Check if the connected account owns this token
                if (owner.toLowerCase() === connectedAccount.toLowerCase()) {
                    // Get token metadata
                    const tokenURI = await contract.tokenURI(i);
                    
                    // Handle IPFS URIs
                    const formattedURI = tokenURI.replace("ipfs://", "https://gateway.pinata.cloud/ipfs/");
                    
                    // Fetch metadata
                    const response = await fetch(formattedURI);
                    if (!response.ok) {
                        console.warn(`NFT metadata not found for token #${i}, skipping.`);
                        continue;
                    }
                    
                    const metadata = await response.json();
                    if (!metadata || !metadata.image) {
                        continue; // Skip invalid NFTs
                    }

                    // Format image URL if it's IPFS
                    const imageUrl = metadata.image.replace("ipfs://", "https://gateway.pinata.cloud/ipfs/");
                    
                    // Check if NFT is listed and get listing details
                    const isListed = await checkIfNFTIsListed(i);
                    let listingDetails = null;
                    if (isListed) {
                        listingDetails = await getListingDetails(i);
                    }
                    
                    // Create NFT object
                    const nft = {
                        id: i,
                        name: metadata.name,
                        description: metadata.description || '',
                        image: imageUrl,
                        price: metadata.price || 0,
                        tokenId: i,
                        contractAddress: CONTRACT_ADDRESS,
                        owner: owner,
                        isListed: isListed,
                        listingDetails: listingDetails
                    };
                    
                    // Add to our array
                    ownedNFTs.push(nft);
                }
            } catch (error) {
                console.error(`Error processing NFT #${i}:`, error);
            }
        }

        // Display NFTs or empty state
        if (ownedNFTs.length > 0) {
            // Clear and hide empty state
            nftGrid.innerHTML = '';
            emptyState.classList.add('hidden');
            
            // Display each NFT with proper listing status
            for (const nft of ownedNFTs) {
                await displayNFTCard(nft, nftGrid);
            }
        } else {
            // Show empty state
            nftGrid.innerHTML = '';
            emptyState.classList.remove('hidden');
        }
        
    } catch (error) {
        console.error('Error loading NFTs from contract:', error);
        nftGrid.innerHTML = '<div class="col-span-full text-center py-12"><i class="fas fa-exclamation-circle text-3xl text-red-500"></i><p class="mt-2 text-gray-600">Failed to load your NFTs. Please try again.</p></div>';
    }
}

// Function to display NFT card with proper listing status
async function displayNFTCard(nft, container) {
    const nftCard = document.createElement('div');
    nftCard.className = 'card card-hover bg-white rounded-xl shadow-md overflow-hidden';
    
    // Determine the status badge and buttons based on listing status
    let statusBadge = '';
    let actionButtons = '';
    
    if (nft.isListed && nft.listingDetails) {
        // NFT is listed - show listing info and cancel button
        const priceInEth = ethers.utils.formatEther(nft.listingDetails.price);
        const saleTypeText = nft.listingDetails.saleType === 0 ? 'Fixed Price' : 'Auction';
        
        statusBadge = `<div class="absolute top-3 right-3 bg-green-600 text-white px-2 py-1 rounded-full text-xs">Listed: ${priceInEth} ETH</div>`;
        
        actionButtons = `
            <div class="flex justify-between items-center">
                <div class="text-sm text-gray-600">
                    <span class="font-medium">${saleTypeText}</span><br>
                    <span class="text-green-600 font-bold">${priceInEth} ETH</span>
                </div>
                <button 
                    id="cancelBtn-${nft.tokenId}"
                    onclick="confirmCancelListing(${nft.tokenId})" 
                    class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded transition duration-200"
                >
                    Cancel Listing
                </button>
            </div>
        `;
    } else {
        // NFT is not listed - show list for sale button
        statusBadge = `<div class="absolute top-3 right-3 bg-gray-600 text-white px-2 py-1 rounded-full text-xs">Not Listed</div>`;
        
        actionButtons = `
            <div class="flex justify-between items-center">
                <span class="text-gray-600 text-sm">Ready to list</span>
                <button class="list-nft-btn bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded transition duration-200" 
                        data-token-id="${nft.tokenId}" 
                        data-contract="${nft.contractAddress}">
                    List for Sale
                </button>
            </div>
        `;
    }
    
    nftCard.innerHTML = `
        <div class="relative">
            <img src="${nft.image}" alt="${nft.name}" class="w-full h-64 object-cover">
            ${statusBadge}
        </div>
        <div class="p-5">
            <h3 class="text-xl font-semibold mb-2">${nft.name}</h3>
            <p class="text-gray-600 text-sm mb-2">${nft.description || 'No description available'}</p>
            <div class="flex items-center mb-3">
                <img src="${document.getElementById('profileImage').src}" alt="Owner" class="w-8 h-8 rounded-full mr-2">
                <p class="text-gray-600 text-sm">Owned by <span class="font-medium">You</span></p>
            </div>
            ${actionButtons}
        </div>
    `;
    
    container.appendChild(nftCard);
    
    // Add event listener for the list button (only if not listed)
    if (!nft.isListed) {
        const listBtn = nftCard.querySelector('.list-nft-btn');
        if (listBtn) {
            listBtn.addEventListener('click', function() {
                const tokenId = this.getAttribute('data-token-id');
                const contractAddress = this.getAttribute('data-contract');
                openListingModal(tokenId, contractAddress);
            });
        }
    }
}

// Function to open the listing modal
function openListingModal(tokenId, contractAddress) {
    // Create modal if it doesn't exist
    if (!document.getElementById('listNftModal')) {
        createListingModal();
    }
    
    // Store token ID and contract address
    document.getElementById('nftTokenId').value = tokenId;
    document.getElementById('nftContractAddress').value = contractAddress;
    
    // Show the modal
    document.getElementById('listNftModal').classList.remove('hidden');
}


function createListingModal() {
    const modalHtml = `
    <div id="listNftModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl p-6 w-full max-w-md">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-xl font-bold">List NFT for Sale</h3>
                <button id="closeListingModalBtn" class="text-gray-500 hover:text-gray-700">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="space-y-4">
                <div class="flex justify-between mb-4">
                    <label class="text-gray-700">Sale Type</label>
                    <div class="flex">
                        <label class="mr-4">
                            <input type="radio" name="saleType" value="fixed" checked class="mr-1">
                            Fixed Price
                        </label>
                        <label>
                            <input type="radio" name="saleType" value="auction" class="mr-1">
                            Auction
                        </label>
                    </div>
                </div>
                <div>
                    <label class="block text-gray-700 mb-1">Price (ETH)</label>
                    <input id="nftPriceInput" type="number" step="0.0001" min="0" class="w-full border border-gray-300 rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="0.00">
                </div>
                <div id="auctionDurationDiv" class="hidden">
                    <label class="block text-gray-700 mb-3 font-medium">Auction Duration (Max 24 hours)</label>
                    
                    <!-- Duration Type Selection -->
                    <div class="mb-3">
                        <div class="flex space-x-4">
                            <label class="flex items-center">
                                <input type="radio" name="durationType" value="preset" class="mr-2" checked>
                                <span class="text-sm">Quick Select</span>
                            </label>
                            <label class="flex items-center">
                                <input type="radio" name="durationType" value="custom" class="mr-2">
                                <span class="text-sm">Custom Time</span>
                            </label>
                        </div>
                    </div>

                    <!-- Preset Options -->
                    <div id="presetOptions" class="mb-3">
                        <select id="nftDurationSelect" class="w-full border border-gray-300 rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                            <option value="0.25">15 minutes</option>
                            <option value="0.5">30 minutes</option>
                            <option value="1" selected>1 hour</option>
                            <option value="2">2 hours</option>
                            <option value="4">4 hours</option>
                            <option value="6">6 hours</option>
                            <option value="12">12 hours</option>
                            <option value="24">24 hours</option>
                        </select>
                    </div>

                    <!-- Custom Time Input -->
                    <div id="customOptions" class="hidden mb-3">
                        <div class="flex space-x-2">
                            <div class="flex-1">
                                <label class="block text-xs text-gray-600 mb-1">Hours</label>
                                <input type="number" id="customHours" min="0" max="23" value="1" 
                                       class="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                            </div>
                            <div class="flex-1">
                                <label class="block text-xs text-gray-600 mb-1">Minutes</label>
                                <input type="number" id="customMinutes" min="0" max="59" value="0" step="5"
                                       class="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                            </div>
                        </div>
                        <div class="text-xs text-gray-500 mt-1">
                            Maximum: 24 hours total
                        </div>
                    </div>

                    <!-- Duration Display -->
                    <div class="bg-gray-50 rounded-md p-2 text-sm mb-2">
                        <span class="text-gray-600">Auction will end in: </span>
                        <span id="durationDisplay" class="font-medium text-indigo-600">1 hour</span>
                    </div>
                </div>
                <input type="hidden" id="nftTokenId">
                <input type="hidden" id="nftContractAddress">
                <input type="hidden" id="finalDurationHours" value="1">
                <button id="confirmListingBtn" class="w-full gradient-bg text-white font-medium py-2 px-6 rounded-md hover:opacity-90 transition duration-300 mt-4">
                    List NFT
                </button>
            </div>
        </div>
    </div>`;

    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    // Initialize duration functionality
    initializeDurationControls();
    
    // Existing modal event listeners
    setupModalEventListeners();
}

function initializeDurationControls() {
    const presetSelect = document.getElementById('nftDurationSelect');
    const customHours = document.getElementById('customHours');
    const customMinutes = document.getElementById('customMinutes');
    const durationDisplay = document.getElementById('durationDisplay');
    const presetOptions = document.getElementById('presetOptions');
    const customOptions = document.getElementById('customOptions');
    const finalDurationInput = document.getElementById('finalDurationHours');
    
    let currentDurationHours = 1;

    // Radio button handlers
    document.querySelectorAll('input[name="durationType"]').forEach(radio => {
        radio.addEventListener('change', function() {
            if (this.value === 'preset') {
                presetOptions.classList.remove('hidden');
                customOptions.classList.add('hidden');
                updateDurationFromPreset();
            } else {
                presetOptions.classList.add('hidden');
                customOptions.classList.remove('hidden');
                updateDurationFromCustom();
            }
        });
    });

    // Preset selection handler
    presetSelect.addEventListener('change', updateDurationFromPreset);

    // Custom input handlers
    customHours.addEventListener('input', updateDurationFromCustom);
    customMinutes.addEventListener('input', updateDurationFromCustom);

    function updateDurationFromPreset() {
        const hours = parseFloat(presetSelect.value);
        currentDurationHours = hours;
        finalDurationInput.value = hours;
        updateDisplay(hours);
    }

    function updateDurationFromCustom() {
        const hours = parseInt(customHours.value) || 0;
        const minutes = parseInt(customMinutes.value) || 0;
        
        // Validate 24-hour limit
        const totalHours = hours + (minutes / 60);
        if (totalHours > 24) {
            if (hours >= 24) {
                customHours.value = 23;
                customMinutes.value = 59;
            } else {
                const maxMinutes = (24 - hours) * 60;
                customMinutes.value = Math.min(minutes, maxMinutes - 1);
            }
            return updateDurationFromCustom();
        }
        
        currentDurationHours = totalHours;
        finalDurationInput.value = totalHours;
        updateDisplay(totalHours);
    }

    function updateDisplay(totalHours) {
        const hours = Math.floor(totalHours);
        const minutes = Math.round((totalHours - hours) * 60);
        
        let displayText = '';
        if (hours > 0 && minutes > 0) {
            displayText = `${hours}h ${minutes}m`;
        } else if (hours > 0) {
            displayText = `${hours} hour${hours !== 1 ? 's' : ''}`;
        } else if (minutes > 0) {
            displayText = `${minutes} minute${minutes !== 1 ? 's' : ''}`;
        } else {
            displayText = '0 minutes';
        }
        
        durationDisplay.textContent = displayText;
    }

    // Initialize display
    updateDurationFromPreset();
}

function setupModalEventListeners() {
    // Sale type radio buttons
    document.querySelectorAll('input[name="saleType"]').forEach(radio => {
        radio.addEventListener('change', function() {
            const auctionDiv = document.getElementById('auctionDurationDiv');
            if (this.value === 'auction') {
                auctionDiv.classList.remove('hidden');
            } else {
                auctionDiv.classList.add('hidden');
            }
        });
    });

    // Close modal button
    document.getElementById('closeListingModalBtn').addEventListener('click', function() {
        document.getElementById('listNftModal').classList.add('hidden');
    });
    
    // Confirm listing button
    document.getElementById('confirmListingBtn').addEventListener('click', function() {
        const saleType = document.querySelector('input[name="saleType"]:checked').value;
        const price = document.getElementById('nftPriceInput').value;
        const durationHours = document.getElementById('finalDurationHours').value;
        const tokenId = document.getElementById('nftTokenId').value;
        const contractAddress = document.getElementById('nftContractAddress').value;
         listNFTForSaleOnBlockchain();
        // Your listing logic here
        console.log('Listing NFT:', {
            saleType,
            price,
            durationHours: saleType === 'auction' ? durationHours : null,
            tokenId,
            contractAddress
        });
        
        // Close modal after listing
        document.getElementById('listNftModal').classList.add('hidden');
    });

    // Close modal when clicking outside
    document.getElementById('listNftModal').addEventListener('click', function(e) {
        if (e.target === this) {
            this.classList.add('hidden');
        }
    });
}

// Function to show the modal and set NFT data
function showListingModal(tokenId, contractAddress) {
    document.getElementById('nftTokenId').value = tokenId;
    document.getElementById('nftContractAddress').value = contractAddress;
    document.getElementById('listNftModal').classList.remove('hidden');
}



// Function to format duration display
function formatDurationDisplay(durationInSeconds) {
    if (durationInSeconds < 60) {
        return `${durationInSeconds} seconds`;
    } else if (durationInSeconds < 3600) {
        const minutes = Math.floor(durationInSeconds / 60);
        return `${minutes} minute${minutes !== 1 ? 's' : ''}`;
    } else {
        const hours = Math.floor(durationInSeconds / 3600);
        const remainingMinutes = Math.floor((durationInSeconds % 3600) / 60);
        if (remainingMinutes > 0) {
            return `${hours} hour${hours !== 1 ? 's' : ''} and ${remainingMinutes} minute${remainingMinutes !== 1 ? 's' : ''}`;
        } else {
            return `${hours} hour${hours !== 1 ? 's' : ''}`;
        }
    }
}

async function listNFTForSaleOnBlockchain() {
    const tokenId = document.getElementById('nftTokenId').value;
    const price = document.getElementById('nftPriceInput').value;
    const saleType = document.querySelector('input[name="saleType"]:checked').value;
    
    // FIXED: Get duration from the correct input field
    const durationHours = saleType === 'auction' ? parseFloat(document.getElementById('finalDurationHours').value) : 0;
    
    if (!price || isNaN(price) || price <= 0) {
        alert('Please enter a valid price');
        return;
    }
    
    // Validate auction duration
    if (saleType === 'auction' && (!durationHours || durationHours <= 0 || durationHours > 24)) {
        alert('Please select a valid auction duration (max 24 hours)');
        return;
    }
    
    try {
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
        
        // Show processing message
        const confirmBtn = document.getElementById('confirmListingBtn');
        const originalText = confirmBtn.textContent;
        confirmBtn.textContent = 'Processing...';
        confirmBtn.disabled = true;
        
        // Convert price to Wei
        const priceInWei = ethers.utils.parseEther(price);
        
        let tx;
        if (saleType === 'fixed') {
            // List for fixed price
            tx = await contract.listNFTFixedPrice(tokenId, priceInWei);
        } else {
            // FIXED: Convert hours to seconds for the smart contract
            const durationInSeconds = Math.floor(durationHours * 3600); // 3600 seconds = 1 hour
            
            // Debug logging with proper duration formatting
            console.log(`Auction Duration Debug:`);
            console.log(`Duration in hours: ${durationHours}`);
            console.log(`Duration in seconds: ${durationInSeconds}`);
            console.log(`Formatted duration: ${formatDurationDisplay(durationInSeconds)}`);
            
            // List for auction with duration in seconds
            tx = await contract.listNFTAuction(tokenId, priceInWei, durationInSeconds);
        }
        
        // Wait for transaction confirmation
        console.log('Transaction sent, waiting for confirmation...');
        const receipt = await tx.wait();
        console.log('Transaction confirmed:', receipt);
        
        // Close the modal
        document.getElementById('listNftModal').classList.add('hidden');
        
        // Show success message with properly formatted duration
        const modal = document.getElementById("list");
        const modalMessage = document.getElementById("modalMessage");

        // Set the message dynamically with proper duration formatting
        if (saleType === 'auction') {
            const durationInSeconds = Math.floor(durationHours * 3600);
            const formattedDuration = formatDurationDisplay(durationInSeconds);
            modalMessage.innerText = `NFT successfully listed for ${price} ETH as an auction for ${formattedDuration}`;
        } else {
            modalMessage.innerText = `NFT successfully listed for ${price} ETH`;
        }

        // Show the modal
        modal.style.display = "flex";

        // Wait a moment for blockchain state to update
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Refresh the display to show updated status
        await loadCreatedNFTsFromContract();
        
    } catch (error) {
        console.error('Error listing NFT for sale:', error);
        alert('Failed to list NFT for sale: ' + error.message);
    } finally {
        // Reset button
        const confirmBtn = document.getElementById('confirmListingBtn');
        if (confirmBtn) {
            confirmBtn.textContent = 'List NFT';
            confirmBtn.disabled = false;
        }
    }
}





// Function to cancel a listing
async function cancelNFTListing(tokenId) {
    try {
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
        
        // Show processing message
        const cancelBtn = document.getElementById(`cancelBtn-${tokenId}`);
        if (cancelBtn) {
            const originalText = cancelBtn.textContent;
            cancelBtn.textContent = 'Cancelling...';
            cancelBtn.disabled = true;
        }
        
        // Call the cancelListing function
        const tx = await contract.cancelListing(tokenId);
        
        // Wait for transaction confirmation
        console.log('Cancel transaction sent, waiting for confirmation...');
        const receipt = await tx.wait();
        console.log('Cancel transaction confirmed:', receipt);
        
        // Show success message
        //alert('Listing cancelled successfully!');
        const modal = document.getElementById("cancel");
        const modalMessage = document.getElementById("modalMessage");

        // Wait a moment for blockchain state to update
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Refresh the display
        await loadCreatedNFTsFromContract();
        
    } catch (error) {
        console.error('Error cancelling listing:', error);
        alert('Failed to cancel listing: ' + error.message);
        
        // Reset button
        const cancelBtn = document.getElementById(`cancelBtn-${tokenId}`);
        if (cancelBtn) {
            cancelBtn.textContent = 'Cancel Listing';
            cancelBtn.disabled = false;
        }
    }
}

// Function to check if an NFT is listed
async function checkIfNFTIsListed(tokenId) {
    try {
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, provider);
        
        // Check if NFT is listed
        const isListed = await contract.isListed(tokenId);
        console.log(`Token ${tokenId} listing status:`, isListed);
        return isListed;
        
    } catch (error) {
        console.error('Error checking listing status for token', tokenId, ':', error);
        return false;
    }
}

// Function to get listing details
async function getListingDetails(tokenId) {
    try {
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, provider);
        
        // Get listing details
        const listing = await contract.getListing(tokenId);
        console.log(`Token ${tokenId} listing details:`, listing);
        return listing;
        
    } catch (error) {
        console.error('Error getting listing details for token', tokenId, ':', error);
        return null;
    }
}

// Confirmation function for cancelling listings
function confirmCancelListing(tokenId) {
  const modal = document.getElementById("cancelModal");
  const confirmBtn = document.getElementById("confirmCancelBtn");
  const dismissBtn = document.getElementById("dismissCancelBtn");

  // Show modal
  modal.style.display = "flex";

  // Ensure old listeners are removed to avoid duplicate triggers
  const newConfirmBtn = confirmBtn.cloneNode(true);
  confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

  // Handle confirm click
  newConfirmBtn.addEventListener("click", () => {
    modal.style.display = "none";
    cancelNFTListing(tokenId); // Your original callback
  });

  // Handle dismiss
  dismissBtn.onclick = () => {
    modal.style.display = "none";
  };

  // Optional: click outside to close
  window.addEventListener('click', function outsideClickClose(e) {
    if (e.target === modal) {
      modal.style.display = "none";
      window.removeEventListener('click', outsideClickClose);
    }
  });
}

async function fetchNFTMetadata(tokenUri) {
    try {
        let metadata = { name: 'Unknown NFT', image: '', description: '' };
        
        if (tokenUri.startsWith('data:application/json;base64,')) {
            // Handle base64 encoded JSON (on-chain metadata)
            const jsonStr = tokenUri.replace('data:application/json;base64,', '');
            metadata = JSON.parse(atob(jsonStr));
        } 
        else if (tokenUri.startsWith('data:application/json,')) {
            // Handle plain JSON (on-chain metadata)
            const jsonStr = tokenUri.replace('data:application/json,', '');
            metadata = JSON.parse(decodeURIComponent(jsonStr));
        }
        else if (tokenUri.startsWith('ipfs://')) {
            // Handle IPFS URIs - convert to HTTP gateway
            const ipfsHash = tokenUri.replace('ipfs://', '');
            const httpUrl = `https://ipfs.io/ipfs/${ipfsHash}`;
            
            const response = await fetch(httpUrl);
            if (response.ok) {
                metadata = await response.json();
            }
        }
        else if (tokenUri.startsWith('http')) {
            // Handle direct HTTP URLs
            const response = await fetch(tokenUri);
            if (response.ok) {
                metadata = await response.json();
            }
        }
        
        // Handle IPFS images
        if (metadata.image && metadata.image.startsWith('ipfs://')) {
            const imageHash = metadata.image.replace('ipfs://', '');
            metadata.image = `https://ipfs.io/ipfs/${imageHash}`;
        }
        
        return metadata;
    } catch (error) {
        console.error('Error fetching NFT metadata:', error);
        return { name: 'Unknown NFT', image: '', description: '' };
    }
}

// Updated loadActiveBids function with proper metadata fetching
// Store countdown intervals to clean them up later
let countdownIntervals = [];

async function loadActiveBids() {
    const activeBidsList = document.getElementById('activeBidsList');
    const emptyBidsState = document.getElementById('emptyBidsState');
    
    // Clear existing intervals
    countdownIntervals.forEach(interval => clearInterval(interval));
    countdownIntervals = [];
    
    const connectedAccount = localStorage.getItem('connectedWalletAccount');
    if (!connectedAccount) {
        activeBidsList.innerHTML = '';
        emptyBidsState.classList.remove('hidden');
        return;
    }

    try {
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, provider);
        
        const userBidsKey = `userBids_${connectedAccount.toLowerCase()}`;
        const userBidRefs = JSON.parse(localStorage.getItem(userBidsKey) || '[]');
        
        const activeBids = [];
        
        for (const bidRef of userBidRefs) {
            try {
                const listing = await contract.getListing(bidRef.tokenId);
                const tokenUri = await contract.tokenURI(bidRef.tokenId);
                
                // Fetch actual metadata
                const metadata = await fetchNFTMetadata(tokenUri);
                
                if (listing.active && 
                    listing.saleType === 1 && 
                    listing.auctionEndTime > Math.floor(Date.now() / 1000)) {
                    
                    const userBidAmount = await contract.auctionBids(bidRef.tokenId, connectedAccount);
                    
                    if (userBidAmount.gt(0)) {
                        const isHighestBid = listing.highestBidder.toLowerCase() === connectedAccount.toLowerCase();
                        
                        activeBids.push({
                            tokenId: bidRef.tokenId,
                            name: metadata.name || `NFT #${bidRef.tokenId}`,
                            image: metadata.image || '/placeholder-nft.png',
                            description: metadata.description || '',
                            amount: ethers.utils.formatEther(userBidAmount),
                            auctionEndTime: listing.auctionEndTime.toNumber(),
                            isHighestBid: isHighestBid,
                            currentHighestBid: ethers.utils.formatEther(listing.highestBid),
                            seller: listing.seller
                        });
                    }
                }
            } catch (error) {
                console.log(`Could not fetch details for token ${bidRef.tokenId}:`, error);
            }
        }

        // Display bids with real-time countdown
        if (activeBids.length > 0) {
            activeBidsList.innerHTML = '';
            emptyBidsState.classList.add('hidden');
            
            activeBids.forEach((bid) => {
                const bidItem = document.createElement('div');
                bidItem.className = 'bg-white p-4 rounded-lg shadow-md border border-gray-100';
                
                // Create unique ID for this countdown element
                const countdownId = `countdown-${bid.tokenId}`;
                
                bidItem.innerHTML = `
<div class="flex items-center gap-4">
                        <img src="${bid.image}" alt="${bid.name}" 
                             class="w-16 h-16 rounded-md object-cover"
                             onerror="this.src='/placeholder-nft.png'">
                        <div class="flex-1">
                            <h3 class="font-medium">${bid.name}</h3>
                            <p class="text-sm text-gray-500">Your bid: ${bid.amount} ETH</p>
                            <p class="text-sm text-gray-500">Current highest: ${bid.currentHighestBid} ETH</p>
                            <p class="text-xs text-red-500 mt-1" id="${countdownId}">Time left: Calculating...</p>
                        </div>
                        <div class="text-right">
                            <span class="text-sm ${bid.isHighestBid ? 'text-green-500' : 'text-yellow-500'}">
                                ${bid.isHighestBid ? 'Highest bid' : 'Outbid'}
                            </span>
                            <div class="mt-2 space-y-1">
                                ${!bid.isHighestBid ? `
                                    
                                ` : ''}
                                <button onclick="withdrawBid('${bid.tokenId}')" 
                                        class="block text-red-600 text-sm hover:text-red-800">
                                    Withdraw bid
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                activeBidsList.appendChild(bidItem);
                
                // Start real-time countdown for this bid
                startCountdown(bid.auctionEndTime, countdownId, bid.tokenId);
            });
        } else {
            activeBidsList.innerHTML = '';
            emptyBidsState.classList.remove('hidden');
        }
        
    } catch (error) {
        console.error('Error loading active bids:', error);
        activeBidsList.innerHTML = '<p class="text-red-500">Error loading bids</p>';
    }
}

function startCountdown(auctionEndTime, countdownId, tokenId) {
    const countdownElement = document.getElementById(countdownId);
    if (!countdownElement) return;
    
    function updateCountdown() {
        const now = Math.floor(Date.now() / 1000);
        const timeLeft = auctionEndTime - now;
        
        if (timeLeft <= 0) {
            countdownElement.innerHTML = '<span class="text-red-600 font-semibold">Auction Ended</span>';
            // Clear this specific interval
            const intervalIndex = countdownIntervals.findIndex(int => int.tokenId === tokenId);
            if (intervalIndex !== -1) {
                clearInterval(countdownIntervals[intervalIndex].interval);
                countdownIntervals.splice(intervalIndex, 1);
            }
            // Optionally reload the bids to remove ended auctions
            setTimeout(() => loadActiveBids(), 2000);
            return;
        }
        
        const hours = Math.floor(timeLeft / (60 * 60));
        const minutes = Math.floor((timeLeft % (60 * 60)) / 60);
        const seconds = timeLeft % 60;
        
        // Format numbers with leading zeros for consistency
        const formattedHours = hours.toString().padStart(2, '0');
        const formattedMinutes = minutes.toString().padStart(2, '0');
        const formattedSeconds = seconds.toString().padStart(2, '0');
        
        countdownElement.innerHTML = `Time left: ${formattedHours}h : ${formattedMinutes}m : ${formattedSeconds}s`;
        
        // Change color as time gets low
        if (timeLeft < 300) { // Less than 5 minutes
            countdownElement.className = 'text-xs text-red-600 mt-1 font-semibold animate-pulse';
        } else if (timeLeft < 3600) { // Less than 1 hour
            countdownElement.className = 'text-xs text-orange-500 mt-1 font-medium';
        } else {
            countdownElement.className = 'text-xs text-red-500 mt-1';
        }
    }
    
    // Update immediately
    updateCountdown();
    
    // Set up interval to update every second
    const interval = setInterval(updateCountdown, 1000);
    countdownIntervals.push({ interval, tokenId });
}

// Call this function when the page is unloaded to clean up intervals
window.addEventListener('beforeunload', function() {
    countdownIntervals.forEach(item => clearInterval(item.interval));
    countdownIntervals = [];
});
// Function to withdraw/cancel a bid (now works with enhanced contract)
async function withdrawBid(tokenId) {
    try {
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
        const account = await signer.getAddress();

        // Check if user is the highest bidder
        const listing = await contract.getListing(tokenId);
        if (listing.highestBidder.toLowerCase() === account.toLowerCase()) {
            await Swal.fire({
                icon: 'warning',
                title: 'Cannot Withdraw',
                text: 'You cannot withdraw your bid because you are currently the highest bidder.',
                confirmButtonColor: '#3085d6'
            });
            return;
        }

        // Confirm withdrawal
        const result = await Swal.fire({
            title: 'Withdraw Bid',
            text: 'Are you sure you want to withdraw your bid? You will get your ETH back.',
            icon: 'question',
            showCancelButton: true,
            confirmButtonText: 'Yes, withdraw',
            cancelButtonText: 'Cancel',
            confirmButtonColor: '#d33',
            cancelButtonColor: '#3085d6'
        });

        if (!result.isConfirmed) return;

        // Call the smart contract withdraw function
        const tx = await contract.withdrawBid(tokenId);
        await tx.wait();

        // Remove from user's local bid references
        const userBidsKey = `userBids_${account.toLowerCase()}`;
        const userBids = JSON.parse(localStorage.getItem(userBidsKey) || '[]');
        const updatedBids = userBids.filter(bid => bid.tokenId !== tokenId);
        localStorage.setItem(userBidsKey, JSON.stringify(updatedBids));

        await Swal.fire({
            icon: 'success',
            title: 'Bid Withdrawn!',
            text: 'Your bid has been withdrawn and ETH refunded.',
            confirmButtonColor: '#3085d6'
        });

        loadActiveBids(); // Reload the list

    } catch (error) {
        console.error('Error withdrawing bid:', error);
        
        let errorMessage = 'Failed to withdraw bid. Please try again.';
        if (error.message.includes('Cannot withdraw - you are the highest bidder')) {
            errorMessage = 'You cannot withdraw your bid because you are currently the highest bidder.';
        } else if (error.message.includes('No bid found')) {
            errorMessage = 'No active bid found for this NFT.';
        }

        await Swal.fire({
            icon: 'error',
            title: 'Error',
            text: errorMessage,
            confirmButtonColor: '#d33'
        });
    }
}

// Update the tab click handlers
// document.addEventListener('DOMContentLoaded', function() {
//     const tabButtons = document.querySelectorAll('[data-tab]');
//     tabButtons.forEach(button => {
//         button.addEventListener('click', function() {
//             // Existing tab switching code...
            
//             // Add specific handling for tabs
//             if (this.dataset.tab === 'created') {
//                 loadCreatedNFTsFromContract();
//             } else if (this.dataset.tab === 'bids') {
//                 loadActiveBids();
//             }
//         });
//     });
    
//     // If "Created" tab is active by default, load NFTs
//     if (document.querySelector('[data-tab="created"]').classList.contains('tab-active')) {
//         loadCreatedNFTsFromContract();
//         //listNFTForSaleOnBlockchain();
//     }
// });

// Enhanced DOMContentLoaded for my-collection page
document.addEventListener('DOMContentLoaded', function() {
    const tabButtons = document.querySelectorAll('[data-tab]');
    tabButtons.forEach(button => {
        button.addEventListener('click', function() {
            // Remove active class from all tabs
            tabButtons.forEach(btn => {
                btn.classList.remove('tab-active', 'bg-indigo-100', 'text-indigo-700');
                btn.classList.add('text-gray-500');
            });
            
            // Add active class to clicked tab
            this.classList.add('tab-active', 'bg-indigo-100', 'text-indigo-700');
            this.classList.remove('text-gray-500');
            
            // Hide all tab contents
            document.querySelectorAll('[data-tab-content]').forEach(content => {
                content.classList.add('hidden');
            });
            
            // Show selected tab content
            const targetContent = document.querySelector(`[data-tab-content="${this.dataset.tab}"]`);
            if (targetContent) {
                targetContent.classList.remove('hidden');
            }
            
            // Load specific content based on tab
            if (this.dataset.tab === 'created') {
                loadCreatedNFTsFromContract();
            } else if (this.dataset.tab === 'bids') {
                loadActiveBids();
            }
        });
    });
    
    // Load initial content based on active tab
    const activeTab = document.querySelector('[data-tab].tab-active');
    if (activeTab && activeTab.dataset.tab === 'bids') {
        loadActiveBids();
    }
});

// Function to refresh all blockchain data (call this after any transaction)
async function refreshBlockchainData() {
    // Refresh homepage
    if (typeof loadListedNFTsFromBlockchain === 'function') {
        loadListedNFTsFromBlockchain();
    }
    
    // Refresh my-collection page if we're on it
    if (document.getElementById('activeBidsList')) {
        loadActiveBids();
    }
}







// Function to delete/cancel a bid
function deleteBid(index, itemId) {
    console.log(`deleteBid appelé avec index=${index}, itemId=${itemId}`);
    
    const connectedAccount = localStorage.getItem('connectedWalletAccount');
    if (!connectedAccount) {
        console.error("Wallet not connected!");
        alert('Wallet not connected!');
        return;
    }
    
    // Get transaction history for the connected wallet
    const transactionKey = `transactionHistory_${connectedAccount.toLowerCase()}`;
    const transactionHistory = JSON.parse(localStorage.getItem(transactionKey) || '[]');
    console.log("Historique des transactions pour suppression:", transactionHistory);
    
    // Confirm before deleting
    if (confirm('Are you sure you want to cancel this bid?')) {
        // Find the bid information before removing it
        const cancelledBid = transactionHistory[index];
        console.log("Enchère à annuler:", cancelledBid);
        
        // Remove bid from transaction history
        transactionHistory.splice(index, 1);
        localStorage.setItem(transactionKey, JSON.stringify(transactionHistory));
        console.log("Historique des transactions mis à jour après suppression");
        
        // Also update the bidHistory for this NFT if itemId is available
        if (itemId && itemId !== 'unknown') {
            console.log(`Mise à jour de l'historique des enchères pour NFT ${itemId}`);
            const bidHistory = JSON.parse(localStorage.getItem(`bidHistory_${itemId}`) || '[]');
            console.log("Historique des enchères pour cet NFT:", bidHistory);
            
            // Find and remove the bid from this account
            const bidIndex = bidHistory.findIndex(b => b.bidder === connectedAccount);
            if (bidIndex !== -1) {
                bidHistory.splice(bidIndex, 1);
                localStorage.setItem(`bidHistory_${itemId}`, JSON.stringify(bidHistory));
                console.log("Enchère supprimée de l'historique des enchères de l'NFT");
            }
            
            // Update the NFT price if needed (revert to previous bid or original price)
            updateNFTPriceAfterCancellation(itemId, connectedAccount, bidHistory);
        }
        
        // Reload bids list
        loadActiveBids();
        
        // Provide feedback
        alert('Bid cancelled successfully!');
    }
}

// Function to update NFT price after a bid cancellation
function updateNFTPriceAfterCancellation(itemId, cancellerAccount, bidHistory) {
    console.log(`updateNFTPriceAfterCancellation pour itemId=${itemId}`);
    
    // Get the NFT data
    const nftData = JSON.parse(localStorage.getItem(`nft_${itemId}`));
    console.log("Données NFT à mettre à jour:", nftData);
    
    if (!nftData) {
        console.log("Aucune donnée NFT trouvée pour cet ID");
        return;
    }
    
    // Only update if the canceller was the highest bidder
    if (nftData.highestBidder === cancellerAccount) {
        console.log("L'utilisateur était l'enchérisseur le plus élevé, mise à jour du prix");
        
        // Sort bid history by amount to find the next highest bid
        const sortedBids = [...bidHistory].sort((a, b) => b.amount - a.amount);
        console.log("Enchères triées:", sortedBids);
        
        if (sortedBids.length > 0) {
            // Set to the next highest bid amount
            nftData.price = sortedBids[0].amount;
            nftData.highestBidder = sortedBids[0].bidder;
            console.log(`Prix mis à jour à ${nftData.price} ETH, nouvel enchérisseur: ${nftData.highestBidder}`);
        } else {
            // No more bids, revert to original price if available or set to 0.01
            nftData.price = nftData.originalPrice;
            delete nftData.highestBidder;
            console.log(`Prix réinitialisé à ${nftData.price} ETH`);
        }
        
        // Save updated NFT data
        localStorage.setItem(`nft_${itemId}`, JSON.stringify(nftData));
        console.log("Données NFT mises à jour dans localStorage");
        
        // Update in the main marketplace listing
        const nftItems = JSON.parse(localStorage.getItem('nftItems') || '[]');
        const itemIndex = nftItems.findIndex(item => item.id == itemId);
        if (itemIndex !== -1) {
            nftItems[itemIndex].price = nftData.price;
            if (nftData.highestBidder) {
                nftItems[itemIndex].highestBidder = nftData.highestBidder;
            } else {
                delete nftItems[itemIndex].highestBidder;
            }
            localStorage.setItem('nftItems', JSON.stringify(nftItems));
            console.log("Liste principale des NFT mise à jour");
        }
        
        // Check and update in created NFTs if present
        const createdNFTs = JSON.parse(localStorage.getItem('createdNFTs') || '[]');
        const createdIndex = createdNFTs.findIndex(item => item.id == itemId);
        if (createdIndex !== -1) {
            createdNFTs[createdIndex].price = nftData.price;
            if (nftData.highestBidder) {
                createdNFTs[createdIndex].highestBidder = nftData.highestBidder;
            } else {
                delete createdNFTs[createdIndex].highestBidder;
            }
            localStorage.setItem('createdNFTs', JSON.stringify(createdNFTs));
            console.log("Liste des NFT créés mise à jour");
        }
    }
}

// Inspection de localStorage pour déboguer
function inspectLocalStorage() {
    console.log("--- INSPECTION DU LOCAL STORAGE ---");
    
    const connectedAccount = localStorage.getItem('connectedWalletAccount');
    console.log("Compte connecté:", connectedAccount);
    
    if (connectedAccount) {
        const transactionKey = `transactionHistory_${connectedAccount.toLowerCase()}`;
        console.log(`Clé de transaction pour ce compte: ${transactionKey}`);
        console.log("Contenu:", localStorage.getItem(transactionKey));
    }
    
    console.log("Tous les éléments dans localStorage:");
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        console.log(`${key}: ${localStorage.getItem(key)}`);
    }
    
    console.log("--- FIN DE L'INSPECTION ---");
}

// Don't forget to call this function when the page loads
document.addEventListener('DOMContentLoaded', function() {
    console.log("DOM chargé, initialisation de la page my-collection");
    
    // Inspecter le localStorage pour déboguer
    inspectLocalStorage();
    
    // Charger les enchères actives
    loadActiveBids();
    
    // Add event listener for wallet connection changes
    const connectWalletBtn = document.getElementById('connectWalletBtn');
    if (connectWalletBtn) {
        console.log("Bouton de connexion de portefeuille trouvé, ajout de l'écouteur d'événements");
        connectWalletBtn.addEventListener('click', function() {
            console.log("Clic sur le bouton de connexion de portefeuille");
            // Reload bids after wallet connection changes
            setTimeout(function() {
                console.log("Rechargement des enchères après changement de connexion");
                loadActiveBids();
            }, 500); // Short delay to ensure localStorage is updated
        });
    } else {
        console.warn("Bouton de connexion de portefeuille non trouvé");
    }

    // Ajouter un bouton de test pour le débogage si nécessaire
    const containerElement = document.querySelector('.container');
  
});

// Don't forget to call this function when the page loads
document.addEventListener('DOMContentLoaded', function() {
    loadActiveBids();
    
    // Add event listener for wallet connection changes
    const connectWalletBtn = document.getElementById('connectWalletBtn');
    if (connectWalletBtn) {
        connectWalletBtn.addEventListener('click', function() {
            // Reload bids after wallet connection changes
            setTimeout(loadActiveBids, 500); // Short delay to ensure localStorage is updated
        });
    }
});

        // // Function to delete a bid
        // function deleteBid(index) {
        //     // Confirm before deleting
        //     if (confirm('Are you sure you want to cancel this bid?')) {
        //         // Get transactions from localStorage
        //         const transactionHistory = JSON.parse(localStorage.getItem('transactionHistory') || '[]');
                
        //         // Find all bids
        //         const bids = transactionHistory.filter(transaction => transaction.type === 'Bid');
                
        //         // Find the bid to delete in the full transaction history
        //         const bidToDelete = bids[index];
        //         const transactionIndex = transactionHistory.findIndex(transaction => 
        //             transaction.type === bidToDelete.type && 
        //             transaction.item === bidToDelete.item && 
        //             transaction.amount === bidToDelete.amount && 
        //             transaction.time === bidToDelete.time
        //         );
                
        //         if (transactionIndex !== -1) {
        //             // Remove the transaction
        //             transactionHistory.splice(transactionIndex, 1);
                    
        //             // Save updated history back to localStorage
        //             localStorage.setItem('transactionHistory', JSON.stringify(transactionHistory));
                    
        //             // Reload the bids display
        //             loadActiveBids();
                    
        //             // Show confirmation
        //             alert('Bid cancelled successfully!');
        //         }
        //     }
        // }
                // Function to add an NFT to the collection
        function addNFT(name, price, imageUrl, creator) {
            // Remove empty state if it's showing
            document.getElementById('emptyState').classList.add('hidden');
            
            // Create NFT card
            const nftCard = document.createElement('div');
            nftCard.className = 'card card-hover bg-white rounded-xl shadow-md overflow-hidden';
            
            nftCard.innerHTML = `
                <div class="relative">
                    <img src="${imageUrl}" alt="${name}" class="w-full h-64 object-cover">
                    <div class="absolute top-3 right-3 bg-indigo-600 text-white px-2 py-1 rounded-full text-xs">${price} ETH</div>
                </div>
                <div class="p-5">
                    <h3 class="text-xl font-semibold mb-2">${name}</h3>
                    <div class="flex items-center mb-3">
                        <img src="https://randomuser.me/api/portraits/men/32.jpg" alt="Creator" class="w-8 h-8 rounded-full mr-2">
                        <p class="text-gray-600 text-sm">Created by <span class="font-medium">${creator}</span></p>
                    </div>
                    <div class="flex justify-between items-center">
                        <button class="gradient-bg text-white text-sm font-medium py-1 px-4 rounded-full hover:opacity-90 transition duration-300">Buy Now</button>
                        <button class="text-gray-500 hover:text-red-500">
                            <i class="far fa-heart"></i>
                        </button>
                    </div>
                </div>
            `;
            
            // Add to the grid
            document.getElementById('nftGrid').appendChild(nftCard);
            
            // Update item count
            const itemCount = document.getElementById('itemCount');
            itemCount.textContent = parseInt(itemCount.textContent) + 1;
        }
        
        // Example function to add an NFT (you can call this from the console or create a button to add NFTs)
        // addNFT('Cosmic Perspective', '3.5', 'https://example.com/nft1.jpg', 'ArtistName');

        // Add this code right after your existing script tag in my-collection.html


    </script>
</body>
</html>